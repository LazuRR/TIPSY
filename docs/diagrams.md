# Архитектура
1. [Проектирование архитектуры](#1) <br>
  1.1 [Тип приложения](#1.1) <br>
  1.1.1 [Android](#1.1.1)<br>
  1.1.2 [Web](#1.1.2)<br>
  1.2 [Стратегия развертывания](#1.2) <br>
  1.3 [Используемые технологии](#1.3) <br>
  1.4 [Реализация сквозной функциональности](#1.4) <br>
  1.5 [Показатели качества](#1.5) <br>
  1.6 [Диаграмма ToBe](#1.6) <br>
2. [Анализ архитектуры](#2) <br>
  2.1 [Анализ](#2.1) <br>
  2.2 [Диаграмма AsIs](#2.2) <br>
  2.3 [Диаграмма классов](#2.3) <br>
3. [Сравнение As Is и To Be, пути улучшения архитектуры](#3) <br>  


## 1. Проектирование архитектуры <a name="1"></a>
### 1.1 Тип приложения<a name="1.1"></a>
#### 1.1.1 Android<a name="1.1.1"></a>
  Данное приложения будет создано на основе мобильной архитектуры. Оно будет состоять из 3 модулей: <br>
- App - отвечает за графическую составляющую приложения: переходы, анимации, блоки для размещения информации с сервера. 
- Recieve - сервис, отвечающий за получение данных с сервера и размещение их в соответствующих окнах приложения.
- Send - сервис, отвечающий за отправку и обновление данных на сервере.

Мы использовали мобильную архитектуру приложения, потому что:
- Пользователи зависят от портативных устройств.
- Приложение поддерживает простой UI, подходящий для использования на
небольшом экране.
- Приложение должно поддерживать сценарии без подключения или без постоянного
подключения.
- Приложение должно быть независимым от устройств и может зависеть от
возможности сетевого подключения.

#### 1.1.2 Web<a name="1.1.2"></a>

 Веб приложение будет создано на основе архитектуры веб-приложения. Оно будет состоять из 3 модулей: <br>
- App - отвечает за графическую составляющую приложения: переходы, анимации, блоки для размещения информации с сервера. 
- Recieve - сервис, отвечающий за получение данных с сервера и размещение их в соответствующих окнах приложения.
- Send - сервис, отвечающий за отправку и обновление данных на сервере.

Веб архитектура подразумевает следующие пункты:
- Требуется обеспечить простую модель развертывания в Веб.
- Пользовательский интерфейс должен быть независимым от платформы.
- Приложение должно быть доступным через Интернет.
- Требуется максимально сократить зависимости на стороне клиента и потребление
ресурсов, таких как дисковое пространство или вычислительные мощности
процессора.


### 1.2 Стратегия развертывания<a name="1.2"></a>
 Основнвые идеомы нераспределнной стратегии развертывания (используется у нас на проекте):
- Используйте нераспределенное развертывание, если Веб-приложение
чувствительно к производительности, поскольку локальные вызовы между слоями
не имеют столь пагубного влияния на производительность, как удаленные вызовы
между уровнями.
- Если с бизнес-логикой будет работать только слой представления и не требуется
обеспечивать ее совместное использование другими приложениями, проектируйте
для бизнес-слоя компонентный интерфейс.
- Если бизнес-логика и логика представления выполняются в одном процессе,
избегайте аутентификации в бизнес-слое.
- Для доступа к базе данных используйте доверенное удостоверение (через модель
доверенной подсистемы). Это повысит производительность и масштабируемость
приложения.
Для развертывания данного приложения будет применяться облачный сервис, площадка Play Market и Heroku. Каждый модуль будет помещен в отдельный снимок - исполняемый пакет, который будет содержать код, все необходимые зависимости и системные переменные. После того, как снимок будет запущен, то он становится отдельной средой выполнения - контейнером. Преимущество данного подхода заключается в том, что приложение выполняется не на отдельной виртуальной машине, а в контейнере, который менее ресурсозатратный и запускается на любой ОС.
  

### 1.3 Используемые технологии<a name="1.3"></a>
  Для написания серверной части выбор пал на SQLite, т.к. базы данных легко портирутся на разные платформы, такие как Android, например. Клиентская часть будет написана при помощи Java в Android studio, т.к.многие знакомы с данным стеком тенологий. Web-версия написана на JS с подключаемыми модулями CSS.
  
### 1.4 Реализация сквозной функциональности<a name="1.1"></a>
  - Сетевое взаимодействие: использовать асинхронные взаимодействия; использовать HTTP протокол.
  - Реализация гибкого интерфейса: удобство работы с блоками для быстрого перепрофилирования приложения.
  - Управление исключениями: обеспечить стабильность состояния приложения после сбоя.
  
### 1.5 Показатели качества<a name="1.5"></a>
  - Концептуальная целостность.
  - Возможность повторного использования.
  - Доступность.
  - Тестируемость.
  - Удобство и простота использования.
  - Взаимодействие с пользователем.
  
### 1.6 Диаграмма ToBe<a name="1.6"></a>
![img](https://github.com/LazuRR/TIPSY/blob/master/docs/mockups/deploy.jpg)

## 2. Анализ архитектуры<a name="2"></a>

### 2.1 Анализ<a name="2.1"></a>
  Архитектура каждого back-end модуля состоит из одинакового набора пакетов:
  - controller - Содержит внутри себя контроллеры, отвечающие на запросы как со стороны пользователя, так и со стороны других приложений.
  - service - Внутри классов данного пакета содержится вся бизнес-логика приложения. CRUD операции над предложениями, заказами и пользовательскими аккаунтами находятся именно здесь.
  - repository - В данном пакете находятся репозитории - интерфейсы, взаимодействующие непосредственно с базой данных.
  - entity - Содержит классы, отображающие сущности и отношения между ними, с которыми работает данное приложение (пользователь, заказ, предложение).
  - dto - Содержат классы, которые представляют сущности в удобном для клиентской части приложения формате.
  - configuration - Классы, выполняющие настройку фреймворка.
  - mapper - Классы, занимающиеся пребразованием сущностей в dto.
  - exception - Наши собственные исключения.
  
  Не очень сложные приложения, построенные на базе Spring Framework, как правило, состоят из данных пакетов. Также для них характерна иерархическая структура: ControllerClass содержит как минимум один ServiceClass и MapperClass. ServiceClass как правило один или несколько RepositoryClass и MapperClass. 
 
### 2.2 Диаграмма AsIs<a name="2.2"></a>

![img](https://github.com/LazuRR/TIPSY/blob/master/docs/mockups/component.jpg)


### 2.3 Диаграмма классов<a name="2.3"></a>

![img](https://github.com/LazuRR/TIPSY/blob/master/docs/mockups/class1.jpg)


### 3. Сравнение As Is и To Be, пути улучшения архитектуры<a name="3"></a>
   В архитектуре As Is, в отличие от архитектуры To Be, представлен проект с точки зрения "как есть" программной части, т.е. отображение логики проекта на уровне взаимодействия компонентов. Диаграмма ToBe представляет собой реализацию взаимодействия конечного пользователя с данными. 
     Пути улучшения архитектуры:
  - реализация обработки исключений.
  - реализация real-time обновления БД. 
